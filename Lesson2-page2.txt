Arbitrum0xe1Bf50052873b06589a280a7dDD2f6bA230Be8a7 0xe1Bf50052873b06589a280a7dDD2f6bA230Be8a7Game contractsTypeUpgradeableChainVersionAddressDiceImmutablePolygon Arbitrumv1.1.2 v1.1.10xA45abc5A7F236B93809bB3228dD6e0b267b26fC4 0x53f61b5127589C19a8A622342cdabfFBDa03dD05Coin FlipImmutablePolygon Arbitrumv1.1.1 v1.1.00x658d831192Bf5008E89ab57B373d8c8C7e6F480e 0xC4A482146c2b493066aa7427D23BeA4F66E5279cSlotsImmutablePolygon Arbitrumv1.1.1 v1.1.00x1109a2D47C6EE842D81bf4D4A36504D4eeB3C8C7 0x76Ca81a08D8D84DD3e6c90a50aC178293D956521Rock Paper ScissorsImmutablePolygon Arbitrumv1.1.1 v1.1.00xb7BF384142A7F82976e65e692Fd4Af7b833aEde5 0x450607DC5955218243ED6334617732d9b2ed7145PlinkoImmutablePolygon Arbitrumv1.1.1 v1.1.00xD971c0407Ae346BDb87Bdb6BFc1efCd0f229FAa0 0x067C6e30607107AE9F438ba800E30584161b81a7Video PokerImmutablePolygon Arbitrumv1.1.1 v1.1.00x5A6b562D1dD4aebE36bf04B3dE29749167D7f672 0x1eDaf4F072a727d58FB78578A1122b4ea879BD5FMinesImmutablePolygon Arbitrumv1.1.2 v1.1.10xE922A4Ad0A406036197661505c3E8dC3B1d327E2 0x574E5249C9C01D266D3f94162Ca285D6e0Ea6EbbMetaplayTypeUpgradeableChainAddressTrusted Forwarder (contract)ImmutablePolygon Arbitrum0xf73ab2d782bf6ba97ac4405d2cd4f1135da8dbd9 0xf73ab2d782bf6ba97ac4405d2cd4f1135da8dbd9Operator (bot)n/aPolygon Arbitrum0x43e812520C0a10D776A8bc4c020a695bE2256e51 0x43e812520C0a10D776A8bc4c020a695bE2256e51Fee receiver and converter (bot) n/aPolygon Arbitrum0x30ed72a13313A385b07E00d9C4BF598CF59BAB89 0x30ed72a13313A385b07E00d9C4BF598CF59BAB89PreviousSelf ExclusionNextAuditsLast updated 1 year ago Page: https://docs.zkasino.io/developer/metaplay#backend-gas-relayer Metaplay | ZKasino DocumentationZKasino DocumentationWebsitedAppTwitterTelegramMoreWebsitedAppTwitterTelegramSearch...Ctrl + KWelcomeTokenomicsZKasino BridgeZKasino Chain TestnetZKasinoRoadmap and FAQResponsible GamingLive SupportIPFS hostingMainnet GuideOfficial LinksPlatformGlossaryBettingChains and Bet tokensSelf ExclusionDeveloperContract addressesAuditsInfrastructureVRF OracleArchitectureMetaplayProbability, Odds and House EdgeDicePlinkoVideo PokerSlotsMinesRock Paper ScissorsCoin FlipKelly-based bankroll managementChangelogGame contracts v2.1Game contracts v2.0Contracts v1.0Integrated VRFs (old)Testnet Guide (outdated)TestingBNB Chain private fee testingv2.1 private testnet WIPv2.0 public testnetv2.0 private testnetmulti-chain private mainnet with VRFv1.1 public testnetmulti-chain private testnet with VRFv1.0 public testnetwip v1.0 private testnetv2.1 public testnetPowered by GitBookOn this pageTechnical flowSession wallet: frontend and trusted forwarderBackend (gas relayer)Trusted forwarder (contract)Game contracts (recipient)Forwarder extraArchitecture overviewFuture improvementsDeveloperMetaplayPreviousArchitectureNextProbability, Odds and House EdgeLast updated 1 year agoMetaplay© is a different way of betting besides regular play. Players can enable Metaplay in their settings. Metaplay© is technically speaking meta transactions combined with session keys. Session keys remove wallet pop ups, a most requested feature. This leads to confirmationless bets. Meta transactions achieve gas abstraction, so users can pay fees with the ERC-20 bet token they are wagering with.Below follows an explanation of the technical flow and architecture of Metaplay©.Technical flowSession wallet: frontend and trusted forwarderWhen a player wants to use Metaplay©, a session wallet is required. The frontend checks if a session private key is stored on localStorage. If a key exists, the frontend uses that key to access the session wallet. This session wallet is allowed to sign requests on behalf of the wallet that generated the session wallet (transaction signer). If a key does not exist yet, the frontend calls an ether.js function to generate a new, random session wallet with a session private key. Ethers guarantees that the key is generated randomly. That key is then stored in the user’s browser in localStorage. This allows the user to keep using Metaplay© across sessions and tabs. The user can delete the key from the browser's localStorage at any given moment:Next, the session wallet is set up on-chain on the Trusted Forwarder contract by calling the setSigner function (involves confirming a transaction). The session wallet address is enabled and saved in the Forwarder contract, the game contracts (‘targets’) are batch approved and an expiry time for the session wallet is set (one month). After one month the user needs to re-approve the Forwarder contract. During this month the user can revoke the allowances on the Forwarder contract for the session wallet at any time. The session wallet can be used for meta transactions based on ERC-2771. This achieves gas abstraction which means that native tokens are no longer required during betting. Fees are paid in ERC-20 bet tokens, such as USDC. Tokens with reliable pricefeeds are eligible to become Metaplay© bet tokens. The user needs to approve the bet tokens on the Forwarder contract (involves confirming a transaction). Note that Metaplay© is unavailable for native tokens (ETH, FTM, MATIC). Whenever a user clicks ‘Play’, the frontend code accesses the session private key from the user. The frontend code uses the key of the session wallet which is authorised to sign EIP-712 signature requests on behalf of the user’s wallet. In short, the frontend handles the signing for the user, removing the need for any pop ups from the wallet. The off-chain request is then sent to the backend server. Malicious intent restrictedIf a malicious party would ever obtain the session private key, their actions are extremely limited. They are unable to steal funds from the wallet, rendering an attack mostly useless since there is no financial gain available.The key can only be used to interact with the game contracts.It is not possible to transfer tokens out of the wallet.Placing wagers can only happen with ERC-20 bet tokens approved on the Forwarder contract.The total amount that can be wagered (volume) is limited to the amount the user has approved on the Forwarder contract.Note: Metamask sets Max to the user's balance and users get warned when approving infinite, leading to increased security.Betting against ~1% house edge does not lead to direct loss of funds; on the contrary, it can lead to profits.Losses do not end up in malicious hands, they fall into the bankroll.Native tokens are unavailable on Metaplay© and thus can never be accessed.In summary: with the key it is only possible to use approved ERC-20 bet tokens and place wagers against ~1% house edge limited to a total volume of the amount approved. A malicious party is unable to get their hands on any funds, meaning there is no incentive to steal the key.Backend (gas relayer)The backend server receives the user’s request. The backend verifies that the transaction does not fail if it gets executed and sends the transaction on-chain. Trusted forwarder (contract)On-chain, the signature and nonce are checked to make sure that the user signed the request to keep the user's wallet safe.The forwarder then sends the request forward, communicating with the recipient/target contracts (game contracts). Game contracts (recipient)The casino contracts underwent minimal changes. The most important change was finding out who is sending the transaction, because the Forwarder contract executes transactions on behalf of the user. This is done with the function function _msgSender(), which can be found on the Common.sol and game contracts. Forwarder extraThe forwarder contract keeps track of the user's "set and signed (immutable) gasLimit and Value sent" to convert those values to the ERC-20 fee token chosen by the user and collected from the user. This is also the reason an approval is needed for the fee token. The operator pays transaction fees and VRF fees, so fees need to be collected from the user to cover the cost from the operator.Architecture overviewFuture improvementsLowering gas costs by batching requests when there is a high number of requests;Especially on Arbitrum, by modifying the calldata so it uses less space on L1 and is therefor cheaper.Decentralising the operator (gas relayers);Subsidising bet fees;Gas fees: gasless transactionsVRF feesAllow approving without native token;Removing approvals for fee token through subsidising those fees;Batch pay upfront for transactions. Page: https://docs.zkasino.io/developer/architecture#transaction-2-vrf-callback-and-payout Architecture | ZKasino DocumentationZKasino DocumentationWebsitedAppTwitterTelegramMoreWebsitedAppTwitterTelegramSearch...Ctrl + KWelcomeTokenomicsZKasino BridgeZKasino Chain TestnetZKasinoRoadmap and FAQResponsible GamingLive SupportIPFS hostingMainnet GuideOfficial LinksPlatformGlossaryBettingChains and Bet tokensSelf ExclusionDeveloperContract addressesAuditsInfrastructureVRF OracleArchitectureMetaplayProbability, Odds and House EdgeDicePlinkoVideo PokerSlotsMinesRock Paper ScissorsCoin FlipKelly-based bankroll managementChangelogGame contracts v2.1Game contracts v2.0Contracts v1.0Integrated VRFs (old)Testnet Guide (outdated)TestingBNB Chain private fee testingv2.1 private testnet WIPv2.0 public testnetv2.0 private testnetmulti-chain private mainnet with VRFv1.1 public testnetmulti-chain private testnet with VRFv1.0 public testnetwip v1.0 private testnetv2.1 public testnetPowered by GitBookOn this pageTransaction 1: Wager and VRF requestTransaction 2: VRF callback and payoutDeveloperArchitecturePreviousVRF OracleNextMetaplayLast updated 1 year agoThe technical flow on the platform for the player using Chainlink-integrated chains (ZKasino uses the Subscription method) happens in two transaction and goes as follows:Transaction 1: Wager and VRF requestThe first transaction consists of placing the wager, paying the VRF fee, receiving a VRF refund and initiating the VRF request:WagerA player calls the Game_Play function on any Game Contract and places a wager. The wager (bet token) is transferred to the Game Contract.VRF feeAn estimation of the VRF fee is charged upfront in the native token for regular play.VRF refundIn the same transaction a partial refund of the VRF fee is sent to the player when the player has initially overpaid for the VRF cost.Randomizer allows an extra refund the next time you play on the same contract if the cost of the callback was superior to the cost estimation.VRF requestThe VRF fee is transferred to the Game Contract (or to the Randomizer VRF contract) and the Game Contract (consumer) calls the requestRandomWords function on the VRFCoordinator contract. The VRFCoordinator emits an event to indicate that a VRF callback should be made.Transaction 2: VRF callback and payoutThe Chainlink node listens to the request randomness events from the VRFCoordinator, generates randomness by mixing the private key with the blockhash of the request and calls the fulfillRandomWords (callback VRF function) on the VRFCoordinator. If there are multiple pending requests the BatchVRFCoordinator is called instead with multiple fulfilments and forwards those to the VRFCoordinator. The Chainlink node waits for requestConfirmations (number in blocks) before responding. ZKasino has set the number of blocks at 3 for Polygon and 1 for Arbitrum.The VRFCoordinator calls the rawFulfillRandomWords on the Game contract.The Game Contract determines the outcome and transfers the wager to the Diamond Contract (bankroll).When the player draws or wins, the bankroll sends the payout to the player at the same time. When the player loses, there is no payout and the bankroll keeps the wager. NotesThe infrastructure is non-custodial. Player's funds are never at risk. If the VRF request fails or if the bankroll can't payout, the transaction either reverts or the wager gets stuck in the Game Contract. The player can then remove their bet with the refund function at Pending VRF Requests on their profile page. While there is a refund mechanism, it is not possible to frontrun transactions for illicit gain. For example, one could try scanning the mempool for losses, frontrunning those transactions to refund them and then only keeping wins. However, this is not possible. On Polygon it is not possible, because refunds only become available when the VRF callback has already become invalid. Furthermore, Arbitrum does not have a mempool.For more information on the Chainlink VRF, read the Chainlink docs: https://docs.chain.link/vrf/v2/subscription. Chainlink's VRF contracts can be found here: https://github.com/smartcontractkit/chainlink/tree/develop/contracts/src/v0.8/vrf. Architecture diagram Page: https://docs.zkasino.io/developer/infrastructure Infrastructure | ZKasino DocumentationZKasino DocumentationWebsitedAppTwitterTelegramMoreWebsitedAppTwitterTelegramSearch...Ctrl + KWelcomeTokenomicsZKasino BridgeZKasino Chain TestnetZKasinoRoadmap and FAQResponsible GamingLive SupportIPFS hostingMainnet GuideOfficial LinksPlatformGlossaryBettingChains and Bet tokensSelf ExclusionDeveloperContract addressesAuditsInfrastructureVRF OracleArchitectureMetaplayProbability, Odds and House EdgeDicePlinkoVideo PokerSlotsMinesRock Paper ScissorsCoin FlipKelly-based bankroll managementChangelogGame contracts v2.1Game contracts v2.0Contracts v1.0Integrated VRFs (old)Testnet Guide (outdated)TestingBNB Chain private fee testingv2.1 private testnet WIPv2.0 public testnetv2.0 private testnetmulti-chain private mainnet with VRFv1.1 public testnetmulti-chain private testnet with VRFv1.0 public testnetwip v1.0 private testnetv2.1 public testnetPowered by GitBookOn this pageBankrollImmutable Game ContractsAccess ControlsDeveloperInfrastructureBankrollZKasino uses one bankroll on each chain: the Diamond Contract. The Diamond Contract follows the diamond upgrade pattern described in EIP-2535: Diamonds, Multi-Facet Proxy. The Diamond Contract holds the bankroll funds and handles the transactions and payouts to the players. The bankroll listens to the immutable BankrollFacet Contract to know how to execute transactions. All Game Contracts communicate separately with the bankroll contract. These diamond contracts made by Nick Mudge have been used. Also OpenZeppelin's ERC-20 standard is used and their Reentrancy Guard.For more information on how the contracts work with each other, visit the Architecture page. To see a list of all clearly labelled contracts, visit the Contracts page.In a future update, the bankroll will be decentralised through bankroll pools. Liquidity providers will receive their share in revenue equal to the increase of the bankroll.Immutable Game ContractsThe Game Contracts can't be upgraded and are thus immutable.Plinko and MinesThe game contracts Plinko and Mines have a multiplier function, but these do not affect immutability or centralisation. An explanation:The function Plinko.setPlinkoMultipliers() is needed because it is not possible to set all the Plinko multipliers at once. This exceeds the gas limit, because a lot of data goes into setting the multpliers. Most importantly, the function can't be re-used once the multipliers are set. The function can only be invoked once.The function Mines.Mines_SetMultipliers() has no input, it is only math. Therefore, the team also considers Mines not to be affected by centralization.Access ControlsThe owner of the Diamond Contract (bankroll) is a MultiSig. In the early phase the signers consist of ZKasino team members. The MultiSig-owner can call a few function on the bankroll:withdrawNativeFunds and withdrawFunds: withdraw tokens from the bankroll;CertiK's audit: Notes: It should be observed that players' bets are not moved to the BankrollFacet contract until the games have concluded. Therefore the bets are not directly impacted by the specialized functions mentioned above.setGame: give game contracts access to the bankroll or remove access;setTokenAddress: add token contracts to the bankroll to perform wagers in or remove tokens contracts.There is no timelock since it is vital to act quickly and to be able remove games from the bankroll or withdraw funds in the early stage. Player's wagers are never at risk (see the Architecture page). Furthermore, every Game Contract has a function that the MultiSig-owner can invoke to withdraw VRF fees:transferFees: withdraw VRF fees paid by players in native token from Game Contracts to the bankroll.Additionally, a diamond proxy is utilized to upgrade the bankroll contract. This allows the contract owner to utilize the diamondCut() function to add, replace, or remove functions.MultiSigTypeChainAddressMultiSig 2/3 (owner)Polygon Arbitrum0x2f52AaC7cD0F8a83C15eE933F0b9c00F6A5A2f95 0xF0275f92bc1C69d2B7aF3eA9116e9174374cb479MultiSig signersPolygon Arbitrum 0x62c4d57a469A21c0D1A5F39362195538174535E8 0x8cCf7C95C0C8EE89d3662b315bAfEc929464dee7 0xbbeB869bDe515b330b65f067AAef845D8c559CC5 0x62c4d57a469A21c0D1A5F39362195538174535E8 0x8cCf7C95C0C8EE89d3662b315bAfEc929464dee7 0xbbeB869bDe515b330b65f067AAef845D8c559CC5MultiSig signers follow these policies:All signers must use one of the following desktop wallets (Metamask, WalletConnect, etc)All signers must use an approved browser (Brave, Firefox, etc)All transactions must occur on a dedicated browser instance (rather than a dedicated computer).An approved VPN should be used for all transactions.Committed in writing that the backup of keys are in multiple locations and protected from fire and floodAll signers on all access control addresses must sign a transaction at least once every 3 months. This can be an active transaction or a test transaction.All access control transactions must be executed in a controlled space for example home or office. They should not be signed in public spaces such as coffee shops or airport terminals.PreviousAuditsNextVRF OracleLast updated 1 year ago Page: https://docs.zkasino.io/developer/metaplay#architecture-overview Metaplay | ZKasino DocumentationZKasino DocumentationWebsitedAppTwitterTelegramMoreWebsitedAppTwitterTelegramSearch...Ctrl + KWelcomeTokenomicsZKasino BridgeZKasino Chain TestnetZKasinoRoadmap and FAQResponsible GamingLive SupportIPFS hostingMainnet GuideOfficial LinksPlatformGlossaryBettingChains and Bet tokensSelf ExclusionDeveloperContract addressesAuditsInfrastructureVRF OracleArchitectureMetaplayProbability, Odds and House EdgeDicePlinkoVideo PokerSlotsMinesRock Paper ScissorsCoin FlipKelly-based bankroll managementChangelogGame contracts v2.1Game contracts v2.0Contracts v1.0Integrated VRFs (old)Testnet Guide (outdated)TestingBNB Chain private fee testingv2.1 private testnet WIPv2.0 public testnetv2.0 private testnetmulti-chain private mainnet with VRFv1.1 public testnetmulti-chain private testnet with VRFv1.0 public testnetwip v1.0 private testnetv2.1 public testnetPowered by GitBookOn this pageTechnical flowSession wallet: frontend and trusted forwarderBackend (gas relayer)Trusted forwarder (contract)Game contracts (recipient)Forwarder extraArchitecture overviewFuture improvementsDeveloperMetaplayPreviousArchitectureNextProbability, Odds and House EdgeLast updated 1 year agoMetaplay© is a different way of betting besides regular play. Players can enable Metaplay in their settings. Metaplay© is technically speaking meta transactions combined with session keys. Session keys remove wallet pop ups, a most requested feature. This leads to confirmationless bets. Meta transactions achieve gas abstraction, so users can pay fees with the ERC-20 bet token they are wagering with.Below follows an explanation of the technical flow and architecture of Metaplay©.Technical flowSession wallet: frontend and trusted forwarderWhen a player wants to use Metaplay©, a session wallet is required. The frontend checks if a session private key is stored on localStorage. If a key exists, the frontend uses that key to access the session wallet. This session wallet is allowed to sign requests on behalf of the wallet that generated the session wallet (transaction signer). If a key does not exist yet, the frontend calls an ether.js function to generate a new, random session wallet with a session private key. Ethers guarantees that the key is generated randomly. That key is then stored in the user’s browser in localStorage. This allows the user to keep using Metaplay© across sessions and tabs. The user can delete the key from the browser's localStorage at any given moment:Next, the session wallet is set up on-chain on the Trusted Forwarder contract by calling the setSigner function (involves confirming a transaction). The session wallet address is enabled and saved in the Forwarder contract, the game contracts (‘targets’) are batch approved and an expiry time for the session wallet is set (one month). After one month the user needs to re-approve the Forwarder contract. During this month the user can revoke the allowances on the Forwarder contract for the session wallet at any time. The session wallet can be used for meta transactions based on ERC-2771. This achieves gas abstraction which means that native tokens are no longer required during betting. Fees are paid in ERC-20 bet tokens, such as USDC. Tokens with reliable pricefeeds are eligible to become Metaplay© bet tokens. The user needs to approve the bet tokens on the Forwarder contract (involves confirming a transaction). Note that Metaplay© is unavailable for native tokens (ETH, FTM, MATIC). Whenever a user clicks ‘Play’, the frontend code accesses the session private key from the user. The frontend code uses the key of the session wallet which is authorised to sign EIP-712 signature requests on behalf of the user’s wallet. In short, the frontend handles the signing for the user, removing the need for any pop ups from the wallet. The off-chain request is then sent to the backend server. Malicious intent restrictedIf a malicious party would ever obtain the session private key, their actions are extremely limited. They are unable to steal funds from the wallet, rendering an attack mostly useless since there is no financial gain available.The key can only be used to interact with the game contracts.It is not possible to transfer tokens out of the wallet.Placing wagers can only happen with ERC-20 bet tokens approved on the Forwarder contract.The total amount that can be wagered (volume) is limited to the amount the user has approved on the Forwarder contract.Note: Metamask sets Max to the user's balance and users get warned when approving infinite, leading to increased security.Betting against ~1% house edge does not lead to direct loss of funds; on the contrary, it can lead to profits.Losses do not end up in malicious hands, they fall into the bankroll.Native tokens are unavailable on Metaplay© and thus can never be accessed.In summary: with the key it is only possible to use approved ERC-20 bet tokens and place wagers against ~1% house edge limited to a total volume of the amount approved. A malicious party is unable to get their hands on any funds, meaning there is no incentive to steal the key.Backend (gas relayer)The backend server receives the user’s request. The backend verifies that the transaction does not fail if it gets executed and sends the transaction on-chain. Trusted forwarder (contract)On-chain, the signature and nonce are checked to make sure that the user signed the request to keep the user's wallet safe.The forwarder then sends the request forward, communicating with the recipient/target contracts (game contracts). Game contracts (recipient)The casino contracts underwent minimal changes. The most important change was finding out who is sending the transaction, because the Forwarder contract executes transactions on behalf of the user. This is done with the function function _msgSender(), which can be found on the Common.sol and game contracts. Forwarder extraThe forwarder contract keeps track of the user's "set and signed (immutable) gasLimit and Value sent" to convert those values to the ERC-20 fee token chosen by the user and collected from the user. This is also the reason an approval is needed for the fee token. The operator pays transaction fees and VRF fees, so fees need to be collected from the user to cover the cost from the operator.Architecture overviewFuture improvementsLowering gas costs by batching requests when there is a high number of requests;Especially on Arbitrum, by modifying the calldata so it uses less space on L1 and is therefor cheaper.Decentralising the operator (gas relayers);Subsidising bet fees;Gas fees: gasless transactionsVRF feesAllow approving without native token;Removing approvals for fee token through subsidising those fees;Batch pay upfront for transactions. Page: https://docs.zkasino.io/developer/contract-addresses#metaplay Contract addresses | ZKasino DocumentationZKasino DocumentationWebsitedAppTwitterTelegramMoreWebsitedAppTwitterTelegramSearch...Ctrl + KWelcomeTokenomicsZKasino BridgeZKasino Chain TestnetZKasinoRoadmap and FAQResponsible GamingLive SupportIPFS hostingMainnet GuideOfficial LinksPlatformGlossaryBettingChains and Bet tokensSelf ExclusionDeveloperContract addressesAuditsInfrastructureVRF OracleArchitectureMetaplayProbability, Odds and House EdgeDicePlinkoVideo PokerSlotsMinesRock Paper ScissorsCoin FlipKelly-based bankroll managementChangelogGame contracts v2.1Game contracts v2.0Contracts v1.0Integrated VRFs (old)Testnet Guide (outdated)TestingBNB Chain private fee testingv2.1 private testnet WIPv2.0 public testnetv2.0 private testnetmulti-chain private mainnet with VRFv1.1 public testnetmulti-chain private testnet with VRFv1.0 public testnetwip v1.0 private testnetv2.1 public testnetPowered by GitBookOn this pageBankroll contractsGame contractsMetaplayDeveloperContract addressesBankroll contractsTypeUpgradeableChainAddressDiamond (Bankroll, main)Upgradeable UpgradeablePolygon Arbitrum0x51e99A0D09EeCa8d7EFEc3062AC024B6d0989959 0x51e99A0D09EeCa8d7EFEc3062AC024B6d0989959BankrollFacetImmutablePolygon Arbitrum0xe1Bf50052873b06589a280a7dDD2f6bA230Be8a7 0xe1Bf50052873b06589a280a7dDD2f6bA230Be8a7Game contractsTypeUpgradeableChainVersionAddressDiceImmutablePolygon Arbitrumv1.1.2 v1.1.10xA45abc5A7F236B93809bB3228dD6e0b267b26fC4 0x53f61b5127589C19a8A622342cdabfFBDa03dD05Coin FlipImmutablePolygon Arbitrumv1.1.1 v1.1.00x658d831192Bf5008E89ab57B373d8c8C7e6F480e 0xC4A482146c2b493066aa7427D23BeA4F66E5279cSlotsImmutablePolygon Arbitrumv1.1.1 v1.1.00x1109a2D47C6EE842D81bf4D4A36504D4eeB3C8C7 0x76Ca81a08D8D84DD3e6c90a50aC178293D956521Rock Paper ScissorsImmutablePolygon Arbitrumv1.1.1 v1.1.00xb7BF384142A7F82976e65e692Fd4Af7b833aEde5 0x450607DC5955218243ED6334617732d9b2ed7145PlinkoImmutablePolygon